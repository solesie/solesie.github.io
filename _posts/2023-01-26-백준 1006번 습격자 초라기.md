---
title:  "백준 1006번 습격자 초라기"
excerpt: "백준 1006번 습격자 초라기 풀이"

categories:
  - 알고리즘
tags:
  - 알고리즘
  - 백준
last_modified_at: 2023-01-26
---

![image](https://user-images.githubusercontent.com/33522810/214675023-1e502253-847d-46e3-a4ab-4678ea99cb05.png){: width="30%" height="30%"}       
Good Code, Bad Code 란 책을 읽다가 몇몇 내용을 적용해보고 싶어졌다.     
오랜만에 알고리즘 문제를 풀어보기로 했다.   

## 1. 문제     

<img width="887" alt="image" src="https://user-images.githubusercontent.com/33522810/214676412-9cad3cbd-19f1-4f50-a314-ca2c8b55a573.png">   
<img width="883" alt="image" src="https://user-images.githubusercontent.com/33522810/214676557-c2fc5c46-b6ac-4df2-8d53-a4a79d2af9b4.png">   

## 2. 접근



## 3. 코드

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Pair{
    private final int outer;
    private final int inner;

    Pair(int outer, int inner){
        validateInput(outer, inner);
        this.outer = outer;
        this.inner = inner;
    }
    private void validateInput(int outer, int inner){
        if(outer < 1 || outer > 10000 || inner < 1 || inner > 10000){
            throw new IllegalArgumentException();
        }
    }

    public int getInner(){
        return inner;
    }
    public int getOuter(){
        return outer;
    }
}
/**
 * 원타곤 내부 적의 수를 나타내는 일급 컬렉션이다.
 */
class Onetagon {
    private final List<Pair> onetagon;

    Onetagon(List<Pair> onetagon){
        this.onetagon = new ArrayList<>(onetagon);
    }
    private void validateInput(List<Pair> onetagon){
        if(onetagon == null || onetagon.size() < 1 || onetagon.size() > 10000){
            throw new IllegalArgumentException();
        }

    }

    public int getSize(){
        return onetagon.size();
    }

    /**
     * 원타곤 index 지점의 바깥쪽 적의 수를 반환한다.
     * @throws ArrayIndexOutOfBoundsException 유효하지 않은 index
     */
    public int getOuter(int index){
        return onetagon.get(index).getOuter();
    }

    /**
     * 원타곤 index 지점의 안쪽 적의 수를 반환한다.
     * @throws ArrayIndexOutOfBoundsException 유효하지 않은 index
     */
    public int getInner(int index){
        return onetagon.get(index).getInner();
    }
}

class Penetration {
    private final int N;
    private final int W;
    private final Onetagon onetagon;
    private int[][][] cache; //for dp

    Penetration(int W, Onetagon onetagon){
        this.N = onetagon.getSize();
        this.W = W;
        this.onetagon = onetagon;
        this.cache = new int[N][4][4];
        for(int i = 0; i < N; ++i)
            for(int j = 0; j < 4; ++j)
                for(int k = 0; k < 4; ++k)
                    cache[i][j][k] = -1;
    }

    /**
     * 원타곤 index 지점의 바깥쪽에서, 왼쪽으로 침투할 수 있는지의 여부를 반환한다.
     * @throws ArrayIndexOutOfBoundsException 유효하지 않은 index
     */
    private boolean canPenetrateLeftFromOuter(int index){
        int left = index - 1;
        if(index == 0) {
            left = N - 1;
        }
        //왼쪽에 아무것도 없어서 같은지점을 두번 침투하는 행위는 배제해야한다.
        if(index == left){
            return false;
        }
        return onetagon.getOuter(left) + onetagon.getOuter(index) <= W;
    }

    /**
     * 원타곤 index 지점의 안쪽에서, 왼쪽으로 침투할 수 있는지의 여부를 반환한다.
     * @throws ArrayIndexOutOfBoundsException 유효하지 않은 index
     */
    private boolean canPenetrateLeftFromInner(int index){
        int left = index - 1;
        if(index == 0) {
            left = N - 1;
        }
        if(index == left){
            return false;
        }
        return onetagon.getInner(left) + onetagon.getInner(index) <= W;
    }

    /**
     * 원타곤 index 지점에서 세로로 침투할 수 있는지의 여부를 반환한다.
     * @throws ArrayIndexOutOfBoundsException 유효하지 않은 index
     */
    private boolean canPenetrateByVertical(int index){
        return onetagon.getInner(index) + onetagon.getOuter(index) <= W;
    }

    /**
     * 현재까지의 침투 정보가 prev, last 이고
     * 이번에 침투를 어떻게 할지 결정할 지점이 here 일때,
     * 남은 구역을 커버하기 위해 필요한 특수 소대의 최소 개수를 반환한다.
     *
     * @param here 이번에 병력을 어떻게 지원할지 결정할 지점이다.
     * @param prev here - 1 에 병력이 어떻게 배치되어 있는지를 나타낸다. <br>
     *             0: 둘다 배치되어 있지 않다. <br>
     *             1: outer 만 배치되어 있다. <br>
     *             2: inner 만 배치되어 있다. <br>
     *             3: 둘다 배치되어 있다.
     * @param last N - 1 에 병력이 어떻게 배치되어 있는지를 나타낸다.
     * @return 남은 구역을 커버하기 위해 필요한 특수 소대의 최소 개수
     */
    private int findMinTroops(int here, int prev, int last){
        boolean canPenetrateLeftFromOuter = canPenetrateLeftFromOuter(here);
        boolean canPenetrateLeftFromInner = canPenetrateLeftFromInner(here);
        boolean canPenetrateByVertical = canPenetrateByVertical(here);
        //base case
        if(here == N - 1){
            if(here == 0){
                if(canPenetrateByVertical) return 1;
                return 2;
            }

            if(last == 0){
                if(prev == 0){
                    // N - 2 지점에 아무 병력도 배치되어 있지 않으므로,
                    // 빈 구역이 없도록 하기 위해서는 outer, inner 둘 다 병력을 왼쪽으로 침투시켜야 한다.
                    if(canPenetrateLeftFromInner && canPenetrateLeftFromOuter) return 2;
                }
                if(prev == 1){
                    // N - 2 지점에는 outer 에 병력이 배치되어있고, N - 1지점에는 아무 병력도 배치되어있지 않으므로,
                    // 빈 구역이 없도록 하기 위해서는 inner 에 왼쪽 병력을 침투시켜야 한다.
                    if(canPenetrateLeftFromInner) return 2;
                }
                if(prev == 2){
                    if(canPenetrateLeftFromOuter) return 2;
                }
                if(prev == 3){
                    if(canPenetrateByVertical) return 1;
                    return 2;
                }
            }
            if(last == 1){
                // 빈 구역이 없도록 하기 위해서는 prev 의 outer 가 비어있으면 안된다.
                if((prev == 1 && canPenetrateLeftFromInner) || prev == 3) return 1;
            }
            if(last == 2){
                if((prev == 2 && canPenetrateLeftFromOuter) || prev == 3) return 1;
            }
            if(last == 3){
                if(prev == 3) return 0;
            }
            return Short.MAX_VALUE;
        }
        // base case: 간결한 코드를 위해 이 함수가 처음 호출되었을 때 경우도 base case 로 택한다.
        if(here == 0){
            int ret = 2 + findMinTroops(here + 1, 3, 0);
            ret = Math.min(ret, 1 + findMinTroops(here + 1, 1, 0));
            ret = Math.min(ret, 1 + findMinTroops(here + 1, 2, 0));
            ret = Math.min(ret, findMinTroops(here + 1, 0, 0));
            if(canPenetrateLeftFromOuter){
                ret = Math.min(ret, 1 + findMinTroops(here + 1, 1, 1));
                ret = Math.min(ret, 2 + findMinTroops(here + 1, 3, 1));
            }
            if(canPenetrateLeftFromInner){
                ret = Math.min(ret, 1 + findMinTroops(here + 1, 2, 2));
                ret = Math.min(ret, 2 + findMinTroops(here + 1, 3, 2));
            }
            if(canPenetrateLeftFromInner && canPenetrateLeftFromOuter){
                ret = Math.min(ret, 2 + findMinTroops(here + 1, 3, 3));
            }
            if(canPenetrateByVertical){
                ret = Math.min(ret, 1 + findMinTroops(here + 1, 3, 0));
            }
            return ret;
        }

        //dynamic programming
        if(cache[here][prev][last] != -1){
            return cache[here][prev][last];
        }
        cache[here][prev][last] = Short.MAX_VALUE;

        if(prev == 0){
            // 빈 구역이 없도록 하기 위해서는 outer, inner 둘 다 병력을 왼쪽으로 침투시켜야 한다.
            if(canPenetrateLeftFromInner && canPenetrateLeftFromOuter){
                cache[here][prev][last] = Math.min(cache[here][prev][last], 2 + findMinTroops(here + 1, 3, last));
            }
        }
        if(prev == 1){
            // 빈 구역이 없도록 하기 위해서는 inner 에 왼쪽 병력을 침투시켜야 한다.
            if(canPenetrateLeftFromInner){
                cache[here][prev][last] = Math.min(cache[here][prev][last], 2 + findMinTroops(here + 1, 3, last));
                cache[here][prev][last] = Math.min(cache[here][prev][last], 1 + findMinTroops(here + 1, 2, last));
            }
        }
        if(prev == 2){
            if(canPenetrateLeftFromOuter){
                cache[here][prev][last] = Math.min(cache[here][prev][last], 2 + findMinTroops(here + 1, 3, last));
                cache[here][prev][last] = Math.min(cache[here][prev][last], 1 + findMinTroops(here + 1, 1, last));
            }
        }
        if(prev == 3){
            if(canPenetrateByVertical) {
                cache[here][prev][last] = Math.min(cache[here][prev][last], 1 + findMinTroops(here + 1, 3, last));
            }
            cache[here][prev][last] = Math.min(cache[here][prev][last], 2 + findMinTroops(here + 1, 3, last));
            cache[here][prev][last] = Math.min(cache[here][prev][last], findMinTroops(here + 1, 0, last));
            cache[here][prev][last] = Math.min(cache[here][prev][last], 1 + findMinTroops(here + 1, 1, last));
            cache[here][prev][last] = Math.min(cache[here][prev][last], 1 + findMinTroops(here + 1, 2, last));
        }
        return cache[here][prev][last];
    }
    /**
     * @return 모든 구역을 커버하기 위한 특수 소대의 최소 개수를 반환한다.
     */
    public int findMinTroops(){
        return findMinTroops(0, 0, 0);
    }
}
```